var tasks = require('../routes/tasks.js')
var ppi = require('../routes/parse-program-input.js')
var lp = require('../routes/line-printer.js')

module.exports = tasks.Tasks.fromObject([
    {
        text: [
            'Задано натуральное число $n$. Напечатать биномиальные коэффициенты $a_0,\\ldots,a_n$ в разложении $(1+x)^n=a_0 + a_1 x + \\ldots + a_n x^n$.',
            'Воспользлваться формулой $a_k = \\frac{n!}{k!(n-k)!}$, а лучше треугольником Паскаля:',
            '<pre>',
            '        1',
            '      1   1',
            '    1   2   1',
            '  1   3   3   1',
            '1   4   6   4   1',
            '       ...',
            '</pre>'].join('\n'),
        scene: ['program', function(stdin) {
            var n = ppi(stdin, 'whole n').n
            if (n > 100)
                throw new Error('Слишком большое n')
            var bc = [1]
            for (var i=1; i<n; ++i) {
                var bc2 = [1]
                for (var j=1; j<i; ++j)
                    bc2.push(bc[j-1] + bc[j])
                bc2.push(1)
                bc = bc2
            }
            return lp().println(bc.join(' ')).finish()
        }],
        stdin: '5',
        stdinHint: 'Введите $n$'
    }, {
        text: 'Даны натуральные числа $n$, $m$, прямоугольная матрица $A$ вещественных чисел (в ней $n$ строк и $m$ столбцов) и столбец $x$ из $m$ элементов. Напечатать матричное произведение $Ax$.',
        scene: ['program', function(stdin) {
            var args = ppi(stdin, 'whole n, whole m, real a[n*m], real x[m]')
            var printer = lp()
            for (var i=0; i<args.n; ++i) {
                var s = 0
                for (var j=0; j<args.m; ++j)
                    s += args.a[i*args.m + j] * args.x[j]
                printer.println(s)
            }
            return printer.finish()
        }],
        stdin: '2 2   10 1 1 100   10 10',
        stdinHint: 'Введите через пробел $n, m, A_{11}, A_{12}, \\ldots A_{nn}, b_1, \\ldots b_n$'
    }
])

/*



Даны натуральные числа $n$, $m$, прямоугольная матрица $A$ вещественных чисел (в ней $n$ строк и $m$ столбцов) и столбец $x$ из $m$ элементов. Напечатать матричное произведение $x^T A$.

Подсчитать и напечатать частоты символов из входного потока. Частота $\\omega_k$ символа $k$ определяется по формуле $\\omega_k=\\frac{n_k}{N}$, где $n_k$ --- количество повторений символа $k$, а $N$ --- общее число символов в потоке. Символы однобайтовые, можно читать их так:
<pre>
while(true) {
    char c; cin >> c;
    if(cin.eof())
        break;
    ...
}
</pre>
Для завершения ввода можно нажать \\verb=Ctrl+Z=; можно при запуске перенаправить ввод из файла: \\verb=program <file.txt=

Заданы две строки с текстом, $p$ и $q$. Определить, встречается ли текст строки $q$ в строке $p$. Если да, то напечатать смещение, начиная с которого в $p$ начинается текст из $q$ (если $q$ встречается в $p$ несколько раз, то напечатать самое маленькое из всех возможных смещений). Строки можно читать из стандартного ввода при помощи функции \\verb=getline()=.

Заданы два натуральных числа, $r$ и $n$. Мультииндекс размера $r$ --- это массив натуральных чисел, каждое от 1 до $n$.
Напечатать все возможные для данных $r$ и $n$ мультииндексы.
Например, при $r=2$ и $n=3$ это будут
пары [1,1], [1,2], [1,3], [2,1], [2,2], [2,3], [3,1], [3,2], [3,3].
% тройки [1,1,1], [1,1,2], [1,2,1], [1,2,2], [2,1,1], [2,1,2], [2,2,1], [2,2,2].
Указание: можно написать функцию инкремента (``увеличения на единицу'') мультииндекса, возвращающую \\verb=true=, если ей это удалось и \\verb=false=, если нет (был передан ``последний'' мультииндекс); вызывать эту функцию в цикле, пока она не вернёт \\verb=false=.

Перестановкой называется упорядоченный набор из чисел $1, 2, \\ldots n$. Заданы число $n$ и массив из $n$ целых чисел. Определить, перестановка в этом массиве или нет (чтобы это была перестановка, все элементы должны быть от 1 до $n$, и они все должны быть различны).

Задано натуральное число $n$ и массив из $2n$ вещественных чисел. Это декартовы координаты векторов на плоскости (в первом и втором элементах --- координаты первого вектора, в третьем и четвёртом --- координаты второго и т.\\,д.). Напечатать координаты самого длинного вектора.

Заданы 8 вещественных чисел. Это декартовы координаты четырёх точек, ${\\bf p}_1$, ${\\bf p}_2$, ${\\bf q}_1$, ${\\bf q}_2$, лежащих на плоскости. Эти точки --- концы двух отрезков на плоскости (один отрезок между точками ${\\bf p}_1$ и ${\\bf p}_2$, другой --- между ${\\bf q}_1$ и ${\\bf q}_2$). Определить, пересекаются отрезки или нет. Указание. Отрезки пересекаются, если концы каждого из них лежат по разные стороны прямой, содержащей другой отрезок; о том, с какой стороны, например, точка ${\\bf q}_1$ от прямой, содержащей отрезок между ${\\bf p}_1$ и ${\\bf p}_2$, можно судить по знаку смешанного произведения $({\\bf q}_1-{\\bf p}_1)\\times({\\bf p}_2-{\\bf p}_1)\\cdot {\\bf k}$ (орт ${\\bf k}$ перпендикулярен плоскости). Смешанное произведение вычисляется так: ${\\bf a}\\times{\\bf b}\\cdot {\\bf k}=a_1b_2-a_2b_1$ ($a_1$, $a_2$ и $b_1$, $b_2$ --- координаты ${\\bf a}$ и ${\\bf b}$ соответственно).
TODO: intersect


Автодорога состоит из $n$ дуг окружности радиусов $R_1,\\ldots,R_n$. Расставьте знаки ограничения скорости на каждой дуге, исходя из требования непревышения заданного ускорения $a_{\\max}$. Учтите, что максимально допустимая скорость в любом случае не должна превышать заданную $v_{\\max}$. Указание. При постоянной скорости движения $v$ по дуге радиуса $R$ ускорение $a=\\omega^2 R$, где $\\omega$ --- угловая скорость: $v=\\omega R$.

Входной поток состоит из слов, разделённых пробелами. Напечатайте палиндромы (слова, читающиеся одинаково слева направо и справа налево, например, \\textit{шалаш}), встречающиеся среди этих слов и состоящие не менее, чем из трёх букв; не печатайте одни и те же слова по нескольку раз. Указание: строками (\\verb=std::string=, \\verb=QString=) можно пользоваться как массивами; в частности, размер можно узнать при помощи метода \\verb=size()=. Уже напечатанные слова можно хранить в \\verb=std::set<std::string>= или \\verb=QSet<QString>=.

В квадратном зале пол покрыт квадратными плитками ($2n$ плиток в длину и столько же в ширину); зал разделён двумя перегородками на 4 одинаковые квадратные части. В каждой половине каждой перегородки имеется проём шириной в одну плитку. В одном углу зала, на плитке с координатами $(1,1)$, стоит робот; в другом углу с координатами $(2n,2n)$ стоит другой робот. Как им поменяться местами и при этом не встретиться друг с другом и с перегородками? Напечатайте траектории их движения. Каждый робот может делать шаги в любую из четырёх сторон на одну плитку.
TODO: robots
*/
